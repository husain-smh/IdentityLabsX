import { Collection } from 'mongodb';
import clientPromise from '../../mongodb';
import { roundToHour } from './utils';

// ===== TypeScript Interfaces =====

export interface MetricSnapshot {
  _id?: string;
  campaign_id: string;
  snapshot_time: Date; // Hourly or daily
  total_likes: number;
  total_retweets: number;
  total_quotes: number;
  total_replies: number;
  total_views: number;
  /**
   * Sum of quoteViewsFromQuotes across all campaign tweets at this snapshot time.
   * Represents total views generated by quote tweets (not included in total_views).
   */
  total_quote_views: number;
  tweet_breakdown: {
    main_twt: {
      likes: number;
      retweets: number;
      quotes: number;
      replies: number;
      views: number;
    };
    influencer_twt: {
      likes: number;
      retweets: number;
      quotes: number;
      replies: number;
      views: number;
    };
    investor_twt: {
      likes: number;
      retweets: number;
      quotes: number;
      replies: number;
      views: number;
    };
  };
  created_at: Date;
}

export interface CreateMetricSnapshotInput {
  campaign_id: string;
  snapshot_time: Date;
  total_likes: number;
  total_retweets: number;
  total_quotes: number;
  total_replies: number;
  total_views: number;
   total_quote_views: number;
  tweet_breakdown: MetricSnapshot['tweet_breakdown'];
}

// ===== Collection Getter =====

export async function getMetricSnapshotsCollection(): Promise<Collection<MetricSnapshot>> {
  const client = await clientPromise;
  const db = client.db();
  return db.collection<MetricSnapshot>('socap_metric_snapshots');
}

// ===== Indexes =====

export async function createMetricSnapshotIndexes(): Promise<void> {
  const collection = await getMetricSnapshotsCollection();
  
  await collection.createIndex({ campaign_id: 1, snapshot_time: 1 });
  await collection.createIndex({ campaign_id: 1, snapshot_time: -1 });
  await collection.createIndex({ campaign_id: 1 });
}

// ===== Helper Functions =====

// roundToHour is imported from ./utils
export { roundToHour };

/**
 * Round timestamp to the start of day for daily snapshots
 */
export function roundToDay(timestamp: Date): Date {
  const rounded = new Date(timestamp);
  rounded.setHours(0, 0, 0, 0);
  return rounded;
}

// ===== CRUD Operations =====

export async function createMetricSnapshot(
  input: CreateMetricSnapshotInput
): Promise<MetricSnapshot> {
  const collection = await getMetricSnapshotsCollection();
  
  const snapshot: MetricSnapshot = {
    ...input,
    created_at: new Date(),
  };
  
  const result = await collection.insertOne(snapshot);
  snapshot._id = result.insertedId.toString();
  
  return snapshot;
}

export async function getMetricSnapshotsByCampaign(
  campaignId: string,
  options?: {
    startDate?: Date;
    endDate?: Date;
    granularity?: 'hour' | 'day';
  }
): Promise<MetricSnapshot[]> {
  const collection = await getMetricSnapshotsCollection();
  
  const query: any = { campaign_id: campaignId };
  
  if (options?.startDate || options?.endDate) {
    query.snapshot_time = {};
    if (options.startDate) {
      query.snapshot_time.$gte = options.startDate;
    }
    if (options.endDate) {
      query.snapshot_time.$lte = options.endDate;
    }
  }
  
  return await collection.find(query).sort({ snapshot_time: 1 }).toArray();
}

export async function getLatestMetricSnapshot(campaignId: string): Promise<MetricSnapshot | null> {
  const collection = await getMetricSnapshotsCollection();
  
  return await collection
    .findOne(
      { campaign_id: campaignId },
      { sort: { snapshot_time: -1 } }
    );
}

